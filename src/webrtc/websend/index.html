<html>

<head>
    <script src="https://cdn.jsdelivr.net/gh/emn178/js-md5/build/md5.min.js"></script>
    <style>
        #byte_content {
            margin: 5px 0;
            max-height: 100px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #byte_range {
            margin-top: 5px;
        }
    </style>

</html>

<body>
    <input type="file" id="files" name="file" /> Read bytes:
    <span class="readBytesButtons">
        <button data-startbyte="0" data-endbyte="4">1-5</button>
        <button data-startbyte="5" data-endbyte="14">6-15</button>
        <button data-startbyte="6" data-endbyte="7">7-8</button>
        <button>entire file</button>
    </span>
    <div id="byte_range"></div>
    <div id="byte_content"></div>
    Base64: <textarea id="remoteSessionDescription"></textarea> <br />
    <button onclick="startSession()"> Send Message </button> <br />
    <script src="wasm_exec.js"></script>
    <script>
    const go = new Go();
    WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject).then((result) => {
        go.run(result.instance);
    });
    </script>
    <script>
    function readBlob(opt_startByte, opt_stopByte) {

        var files = document.getElementById('files').files;
        if (!files.length) {
            alert('Please select a file!');
            return;
        }

        var file = files[0];
        var start = parseInt(opt_startByte) || 0;
        var stop = parseInt(opt_stopByte) || file.size - 1;

        var reader = new FileReader();

        // If we use onloadend, we need to check the readyState.
        reader.onloadend = function(evt) {
            if (evt.target.readyState == FileReader.DONE) { // DONE == 2
                document.getElementById('byte_content').textContent = evt.target.result;
                document.getElementById('byte_range').textContent = ['Read bytes: ', start + 1, ' - ', stop + 1,
                    ' of ', file.size, ' byte file'
                ].join('');
                sendMessage(evt.target.result);
            }
        };

        var blob = file.slice(start, stop + 1);
        reader.readAsBinaryString(blob);
    }

    document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
        if (evt.target.tagName.toLowerCase() == 'button') {
            var startByte = evt.target.getAttribute('data-startbyte');
            var endByte = evt.target.getAttribute('data-endbyte');
            readBlob(startByte, endByte);
        }
    }, false);




    let pc = new RTCPeerConnection({
        iceServers: [{
            urls: 'stun:stun.l.google.com:19302'
        }]
    })
    let log = msg => {
        console.log(msg);
    }

    pc.onsignalingstatechange = e => log(pc.signalingState)
    pc.oniceconnectionstatechange = e => log(pc.iceConnectionState)
    pc.onicecandidate = event => {
        if (event.candidate === null) {
            log(JSON.stringify(pc.localDescription))
        }
    }



    pc.ondatachannel = e => {
        let dc = e.channel
        log('New DataChannel ' + dc.label)
        dc.onclose = () => log('dc has closed')
        dc.onopen = () => {
            log('dc has opened');
        }
        dc.onmessage = e => {
            log(`Message from DataChannel '${dc.label}' payload '${e.data}'`)
        }
        window.sendMessage = e => {
            let message = e;
            if (message === '') {
                return alert('Message must not be empty')
            }

            dc.send(message)
        }
    }

    window.startSession = () => {
        pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(document.getElementById('remoteSessionDescription').value)))).catch(log)
        pc.createAnswer().then(d => pc.setLocalDescription(d)).catch(log)
    }

    // websockets 
    var socket;
    var sendChannel;
    var pakeData;
    var croc = {
        "SharedSecret": "test1",
        "Key": "",
        "Pake": "",
        "KeyAndSalt": {},
    }

    var checkErr = e => {
        if (typeof e === 'error') {
            throw err;
        }
    }

    var sendMessage = msg => {
        log(`sending ${JSON.stringify(msg)}`)
        socket.send(btoa(JSON.stringify(msg)));
    }

    function waitForGolang() {
        if (typeof writeWebsocketMessage !== "undefined") {
            socket.send(writeWebsocketMessage("[1] you are offerer", "", ""))
        } else {
            setTimeout(waitForGolang, 250);
        }
    }

    const socketMessageListener = (event) => {
        var data = JSON.parse(readWebsocketMessage(event.data, croc.Key));
        if (!("Message" in data)) {
            console.log("no message")
            return
        }
        console.log(`recv: '${data.Message}'`)
        var message = "";
        var payload = "";
        if (data.Message == "[1] you are offerer") {
            croc.Pake = pakeInit(croc.SharedSecret, "0")
            message = "[2] you are answerer"
        } else if (data.Message == "[2] you are answerer") {
            croc.Pake = pakeInit(croc.SharedSecret, "1")
            message = "[3] pake1"
            payload = pakePublic(croc.Pake);
        } else if (data.Message == "[3] pake1" || data.Message == "[4] pake2" || data.Message == "[5] pake3") {
            croc.Pake = pakeUpdate(croc.Pake, data.Payload);
            if (data.Message == "[3] pake1") {
                message = "[4] pake2";
                payload = pakePublic(croc.Pake);
            } else if (data.Message == "[4] pake2") {
                message = "[5] pake3";
                payload = pakePublic(croc.Pake);
            } else if (data.Message == "[5] pake3") {
                croc.KeyAndSalt = JSON.parse(pakeSessionKey(croc.Pake, ""));
                message = "[6] salt";
                payload = croc.KeyAndSalt.Salt;
            }
        } else if (data.Message == "[6] salt") {
            croc.KeyAndSalt = JSON.parse(pakeSessionKey(croc.Pake, data.Payload));
            croc.Key = croc.KeyAndSalt.Key;

            // create offer 
            sendChannel = pc.createDataChannel('data')
            pc.createOffer().then(d => {
                console.log(`send '[7] offer'`);
                console.log(d);
                socket.send(writeWebsocketMessage("[7] offer", btoa(JSON.stringify(d)), croc.Key));
                pc.setLocalDescription(d);
            }).catch(log)
        } else if (data.Message == "[7] offer") {
            console.log(atob(data.Payload));
            pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(data.Payload)))).catch(log)
            pc.createAnswer().then(d => {
                console.log("send '[8] answer'")
                socket.send(writeWebsocketMessage("[8] answer", btoa(JSON.stringify(d)), croc.Key));
                pc.setLocalDescription(d);
            }).catch(log)
        } else if (data.Message == "[8] answer") {
            var localDesc = JSON.parse(atob(data.Payload));
            console.log("local description: " + localDesc);
            pc.setRemoteDescription(new RTCSessionDescription(localDesc)).catch(log);
        }
        if (message != "") {
            console.log(`send '${message}'`);
            socket.send(writeWebsocketMessage(message, payload, croc.Key));
            if (message == "[6] salt") {
                // update the key so future transfers are encrypted
                croc.Key = croc.KeyAndSalt.Key;
            }
        }
    };
    const socketOpenListener = (event) => {
        log('connected to websockets');
        waitForGolang();
    }
    const socketCloseListener = (event) => {
        if (socket) {
            log('Disconnected.');
        }
        // var ws_url = window.origin.replace("http", "ws") + '/ws/test1';
        var ws_url = "ws://localhost:8005/ws/test1";
        log(`connecting to '${ws_url}'`)
        socket = new WebSocket(ws_url);
        socket.addEventListener('open', socketOpenListener);
        socket.addEventListener('message', socketMessageListener);
        socket.addEventListener('close', socketCloseListener);
    };
    socketCloseListener();
    </script>
</body>

</html>